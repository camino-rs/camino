searchState.loadedDescShard("rusty_fork", 0, "Rusty-fork provides a way to “fork” unit tests into …\nWraps a <code>std::process::Child</code> to coordinate state between <code>std</code>…\nA flag was encountered when examining the current process…\nContains the error value\nEnum for errors produced by the rusty-fork crate.\nWraps <code>std::process::ExitStatus</code>. Historically, this was due …\nContains the success value\nGeneral <code>Result</code> type for rusty-fork.\nThe type of the value produced by <code>rusty_fork_id!</code>.\nSpawning a subprocess failed.\nAn unknown flag was encountered when examining the current …\nReturns the exit code of the process, if any.\nSimulate a process fork.\nSupport code for the <code>rusty_fork_test!</code> macro and similar.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the OS-assigned processor identifier associated …\nReturn a reference to the inner <code>std::process::Child</code>.\nReturn a mutable reference to the inner <code>std::process::Child</code>…\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nForces the child to exit. This is equivalent to sending a …\nProduce a hashable identifier unique to the particular …\nRun Rust tests in subprocesses.\nGiven the unqualified name of a <code>#[test]</code> function, produce a\nWas termination successful? Signal termination is not …\nAttempts to collect the exit status of the child if it has …\nReturns the Unix signal which terminated this process.\nWaits for the child to exit completely, returning the …\nWait for the child to exit, but only up to the given …\nSimultaneously waits for the child to exit and collect all …\nTransform a string representing a qualified path as …")